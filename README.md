# What is pygemmes ?

Pygemmes is a huge toolbox for the study of complex models written with dynamical systems. It is aimed mostly, but not only, to ecological economists. 
It can solves : 
* Ordinary differential equations 
* Spatial differential equations, on any type of grid 
* Agent-based models 

In consequence, it is possible to do multisectoral, multiregional, resources-inequalities-climate-international socio-economic system. 

It is :
* An ensemble of fields, concepts that makes sense in our world (temperature, inflation, debt, production, carbon concentration, productivity...)
* And ensemble of links : concepts that are related to each other in their definition or their evolution (the evolution of price is linked to inflation, the employement is linked to the workers and the population...)
* An ensemble of model : each model is an ensemble of links consistent altogether, you can compare each model on its construction and their consequence, couple models...
* An ensemble of tools to study the system : equation solvers, cycles analysis, sensitivity analysis, basin of attractions...

In a few lines one can :
* Explore and plot the litterature
* Write his own model, prototype it
* Analyse the outcomes

```
import pygemmes as pgm
hub = pgm.Hub(model='GK',preset='default')
hub.run()
hub.plot_preset(preset='default')
hub.get_summary()
```
![image](https://user-images.githubusercontent.com/11523050/153495548-7f85f5c3-1cde-452c-8218-bc1a25215f66.png)
*A network automatically generated by the system. It is interactive !*

![image](https://user-images.githubusercontent.com/11523050/153495738-43300d36-bbd7-4454-a2c3-392a8eaa4863.png)
*Automatic plot by units*

![image](https://user-images.githubusercontent.com/11523050/153495829-46588141-fa1d-4ef8-bcec-fc278432279d.png)
*N Y-axis plots*

![image](https://user-images.githubusercontent.com/11523050/153495982-9b080f2d-dbe5-460b-a8ce-04d72c0c0b31.png)
*3D plots*

![image](https://user-images.githubusercontent.com/11523050/153496144-c260b212-1042-4b98-b2bd-26b44f36507c.png)
*Fast-cycle decoupling in analysis*

![image](https://user-images.githubusercontent.com/11523050/153496401-63d8eef8-ec82-4550-a4c9-444038fcedb2.png)
*Sensitivity impact Of initial conditions*

# Structure of the library (general)

![image](https://user-images.githubusercontent.com/11523050/199280909-ef35f3e7-f240-4610-8ad3-b1fa902426c8.png)

# Structure of the library and methods (user side)

![image](https://user-images.githubusercontent.com/11523050/199279983-4c7ed333-3254-4e10-897d-e36b7d6a2d29.png)


# How to use it ?

Execute line by line `doc/Tutorial.py`
Look at file `doc/Introduction.ipynb`


# IS IT AN IAM AS MANY OTHERS ?

The goal of the library is to help the community of modellers, especially the ones working with IAM (Integrated assessment model). However, those are not constructed standard way : it is based on dynamical systems rather than intertemporal optimisation.

As a consequence, the model is much more suited to take into account economy as a part of the world (ecology) rather than seeing the ecology as a part of the economy.
It is much more convenient that way to couple different disciplines that way. This formulation is also stock-flow consistent : nothing appear or disappear out of nowhere by construction. This is a great help to get closer to a thermodynamic consistent model.

The economic part is handled through Post-Keynesian approach, particularly efficient on rapidly-evolving, out of equilibrium dynamics with endogeneous crysis.

In the general methodology, one could see similitudes with 'Limits to growth' but with 50 years of update in term of dynamical systems and interdisciplinary research, and more policy oriented.
The model are based on descriptivity and allow the user to develop normativity.

# Contributing

There are three layers of contributions possible
* User (just have fun with the library and use it for your work)
* Modeller (add new model in the system)
* Developper (add new functionalities)

## Contributing as a User
1. Do the tutorial in `doc\tutorial.py`
2. Try different models and preset
3. Emit `issues` when something looks wrong `https://github.com/DaluS/GEMMES/issues/new`


## Contributing as a Modeller
The goal of a modeller is to implement models given the framework of `pygemmes`


### Try being a user !
1. Do everything in "contributing as a user" section just above
2. Look at the list of proposed model to implement in `https://github.com/DaluS/GEMMES/projects/1`, or choose your own

### Look at the part 'HOW TO WRITE A MODEL`


### Get to know what to put in your economic model (on paper)
1. Choose what sectors you want to put in your model
2. Choose the stocks they have (money, physical units)
3. Choose the flux that links them
4. Write stock-flow consistency (evolution of stock depending of flux)
5. Detail the quantitative values of flux (Metabolix hypothesis, Behavior)
6. You might have some circular dependency in your variable : a first round of simplification might be needed


### Implement everything : in the model file
1. Copy a file model that you think is inspiring and write it with a new name
2. Use all the fields alaready existing in `_def_fields` that exist in your model
3. Use all the function existing in `_def_functions` that correspond to your model
4. Write your presets
5. Define new fields and parameters if needed
6. Define new functions if needed


### Sharing with the community : first pull request
1. Create a branch on your git
2. Put your model file in the `pygemmes` folder
3. Push your branch
4. Do a pull request explaining what you've put inside your model (you can do generalisation directly if you want and avoid the multiple pull request)


### Generalisation : from the model file to the library
This step is optional but appreciated !

0. Create a new branch
1. put all your new fields inside `def_fields` either by creating a new group or adding elements in an existing one
2. put your new functions inside `def_functions`
3. put your new plots inside `def_plots`
4. Re-edit your models calling the functions of these files instead
5. Do a new pull request


## Contributing as a Developper <3
1. First add a model in the system
2. Look at the issues
3. Choose which issue you want to work on and say it on the issue (or raise a new issue)
4. Bring a PR with your new code !


# HOW TO WRITE A MODEL

There are many ways to write a model in **pygemmes**, and one might fit your project better than other ones.
As there are already some stuff coded, you should always have an eye on :
    * Existing models ( list can be obtained using `pgm.get_available_models` or in `_models\model_*.py`
    * Existing fields ( list can be obtained using `pgm.get_available_fields` or in `_models\_def_fields.py`
    * Existing functions ( list can be obtained using `pgm.get_available_functions` or in `_models\_def_functions.py`
That way you do not have to reinvent something that's already been added !

To explore the different approaches one can explore :
     1. `LorenzSystem` which contains all the basis (not using any external source)
     2. `G` as a Goodwin model using both the fields and functions library
     3. `G-CES` as an extension of `G` model

## How to read a model file
A model file is two big dictionnary :
    * `_LOGICS` that contains all the logics that links fields together
    * `_PRESETS` that contains typical values and plots for simulations. it
is a help for new users who wants to understand the typical properties of the model.

### `_LOGICS` Dictionnary
_LOGICS contains in itself 3 dictionnary :
    * ODE which contains all the fields which are defined by a differential equation
    * Statevar which contains all the fields which are defined by a state variables
    * param which contains all the fields which are not changing through time but are
 not defined in pygemmes's library (read `pgm.get_available_fields()` to check)

Check the ipython notebook in `doc/Model_creation.ipynb`

## Code path at initialization (for developper)

1) __config 
2) __init__
3) _core hub __init__
    4) _class_set.load_model 
        * Check model name
        * Load "model" as a dictionnary
        * prepare pygemmes knowledge of fields to be compatible
        * Check completude 
        * Translation from dmodel to dparam 
        * Add pygemmes knowledge 
        * Identification for categories/solving
        * Initial shapes
        * Big dictionnary of pointers
    5) _set_preset
        * set dparam
            * set dimensions
            * set fields 
    6) reset 
7) set dparam
    * set dimensions            
    * set fields 
8) run
    9) _solvers.solve
        10) get_func_dydt
            * Create all buffers and arrays
            * create the function y'=F(y) with F coupling functions

# The Developpers

* Paul Valcke
* Didier Vezinet
