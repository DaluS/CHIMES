"""Network of springs dynamics"""

from chimes.libraries import importmodel      # Import another model _LOGICS, _PRESETS
from chimes.libraries import Operators as O   # Prewritten operators for multisectoral and multiregional coupling. `chm.get_available_Operators()`
from chimes.libraries import fill_dimensions   # When using multisectoral dynamics, fill automatically the sizes of fields
from chimes.libraries import merge_model       # Merge two model logics into each others
from chimes.libraries import Funcs            # Prewritten functions from CHIMES use `chm.get_available_Functions()`
import numpy as np                          # if you need exponential, pi, log

_DESCRIPTION = """
## What is this model ?

A Spring Network is an ensemble of nodes, that are linked by springs. 
Springs, depending of their compression, will apply forces on the nodes they connect. 
Those forces are then going to move the nodes, which change spring tensions. 

Typically, it is an excellent example of local wave propagation on a network structure.

The way it is coded here is the following: 
* Each nodes $_i \in N_{nodes}$ has a position $x_i,y_i$, and a speed $v^x_i,v^y_i$
* The dynamics is a classic $\dot{v}^x_i = (F^x_i - damp*v^y_i)/m_i$ where damp is fluid friction, and F the force resulting from the spring network

### How to represent the spring network 

Spring are here represented by tensors, and not as individuals. 
Preliminarily, we consider $N_{springs}$. They have four characteristics:
1. The index of their first node extremity $I^1_j$
2. The index of their second node extremity $I^2_j $
3. A stiffness $k_j$
4. An unstrenched length $L^0_j$

The strategy is to consider that each node is linked to each node, but with a stiffness 0 by default
In consequence, we define $k_{ij}$ the stiffness matrix of the network

In consequence, the dynamics is : 
$$\dot{v}_i = - \sum_j k_{ij} (dist(x_i,x_j)-L0_{ij}) cos(\theta_i) - \eta v_i$$

With $dist(x_i,x_j)= ((x_i - x_j )**2 + (y_i - y_j )**2)**{1/2}$ and $\theta_i = atan( (y_i-y_j) / (x_i-x_j))$

To create $k_{ij}$ and $L^0_{ij}$:


Instead of calculating this using loops, the calculations can be done using networks.

1. $k$ and $L^0$ are now matrices with 


## Why is it interesting ? 



## what is the purpose of your model,
## Expected behavior

DO NOT EDIT THIS FILE ! COPY AND PASTE IT THEN MODIFY THE COPY TO WRITE YOUR MODEL
"""

_TODO = ['Nothing is done', 'that should be done']
_ARTICLE = "https://en.wikipedia.org/wiki/Spring_system"
_DATE = "2024/06/04"
_CODER = "Paul Valcke"
_KEYWORDS = ['Network', 'springs', 'mesh']

_LOGICS = dict(
    size=dict(
        Nnodes=dict(value=1,
                    definition='Number of nodes in the network'),
    ),
    differential=dict(
        vx=dict(
            func=lambda Fx, m, vx, damp: Fx/m - damp*vx/m,
            definition='horizontal velocity',
            initial=0),
        vy=dict(
            func=lambda Fy, m, vy, damp: Fy/m - damp*vy/m,
            definition='vertical velocity',
            initial=0),
        x=dict(
            func=lambda vx: vx,
            definition='horizontal position',
            initial=0),
        y=dict(
            func=lambda vy: vy,
            definition='vertical position',
            initial=0),
    ),
    statevar=dict(
        dx=dict(func=lambda x: x - np.moveaxis(x, -1, -2)),
        dy=dict(func=lambda y: y - np.moveaxis(y, -1, -2)),

        distance=dict(func=lambda dx, dy: (dx**2 + dy**2)**(1/2)),
        angle=dict(func=lambda dx, dy: np.arctan2(dy, dx)),

        Fmx=dict(func=lambda Kmat, distance, L0Mat, angle: -Kmat*(distance-L0Mat)*np.cos(angle)),
        Fmy=dict(func=lambda Kmat, distance, L0Mat, angle: -Kmat*(distance-L0Mat)*np.cos(angle)),

        Fx=dict(func=lambda Kmat, distance, L0Mat, angle: O.ssum2(-Kmat*(distance-L0Mat)*np.cos(angle))),
        Fy=dict(func=lambda Kmat, distance, L0Mat, angle: O.ssum2(-Kmat*(distance-L0Mat)*np.sin(angle))),

        Kinetic=dict(func=lambda m, vx, vy: 0.5*O.ssum(m*(vx**2 + vy**2))),
        # Potential = dict(func= lambda m,vx,vy: 0.5*O.ssum(Kmat*(distance-L0Mat)**2 ))m
    ),
    parameter=dict(
        L0Mat=1,
        Kmat=1,
        m=1,
        damp=0,
    )
)


def Springlist_to_K_L0(Node1, Node2, k, L0, Nnodes, **kwargs):
    '''Give a weighted matrix representation of a network from a list approach. 
    Node1 and Node2 are the list of nodes at both extremity of the spring
    k is the stiffness of the spring as a list
    l0 is the length at which there is no force in the spring as a list
    Nnodes is the number of nodes in the Network. 
    '''

    k_matrix = np.zeros((Nnodes, Nnodes))
    L0_matrix = np.zeros((Nnodes, Nnodes))

    k_matrix[Node1, Node2] = k
    k_matrix[Node2, Node1] = k

    L0_matrix[Node2, Node1] = L0
    L0_matrix[Node1, Node2] = L0

    return k_matrix, L0_matrix


_SUPPLEMENTS = {'Springlist_to_K_L0': Springlist_to_K_L0}


Dimensions = {
    'scalar': [],
    # 'vector': [],
    'matrix': ['L0Mat', 'Kmat', 'dx', 'dy', 'angle', 'distance', 'Fmx', 'Fmy'],
}
DIM = {'scalar': ['__ONE__'],
       'vector': ['Nnodes'],
       'matrix': ['Nnodes', 'Nnodes']}
_LOGICS = fill_dimensions(_LOGICS, Dimensions, DIM)
